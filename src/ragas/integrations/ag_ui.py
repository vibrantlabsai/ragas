"""
AG-UI Protocol Integration for Ragas.

This module provides conversion utilities and row enrichment for AG-UI protocol
agents. It supports converting AG-UI streaming events to Ragas message format
and running rows against AG-UI FastAPI endpoints for use with the @experiment
decorator pattern.

AG-UI is an event-based protocol for agent-to-UI communication that uses typed
events for streaming text messages, tool calls, and state synchronization. This
integration supports both streaming events (Start-Content-End triads) and
convenience chunk events (TextMessageChunk, ToolCallChunk) for complete messages.

Primary API:
    run_ag_ui_row: Run a single row against an AG-UI endpoint and return enriched data

Conversion Functions:
    convert_to_ragas_messages: Convert AG-UI event sequences to Ragas messages
    convert_messages_snapshot: Convert AG-UI message snapshots to Ragas messages
    convert_messages_to_ag_ui: Convert Ragas messages to AG-UI message format

Extraction Helpers:
    extract_response: Extract concatenated AI response text from messages
    extract_tool_calls: Extract all tool calls from AI messages
    extract_contexts: Extract tool results/contexts from messages

Sample Building:
    build_sample: Build SingleTurnSample or MultiTurnSample for metric scoring

Low-Level:
    call_ag_ui_endpoint: Call an AG-UI endpoint and collect streaming events
    AGUIEventCollector: Collect and reconstruct messages from streaming events

Examples:
    Basic evaluation with @experiment::

        from ragas import experiment
        from ragas.integrations.ag_ui import run_ag_ui_row
        from ragas.metrics.collections import FactualCorrectness

        @experiment()
        async def my_experiment(row):
            # Run row against AG-UI endpoint
            enriched = await run_ag_ui_row(row, "http://localhost:8000/chat")

            # Score with your own metrics
            score = await FactualCorrectness(llm=evaluator_llm).ascore(
                response=enriched["response"],
                reference=row["reference"],
            )

            return {**enriched, "factual_correctness": score.value}

        # Framework handles dataset iteration
        results = await my_experiment.arun(dataset, name="my_eval")

    Tool evaluation with multi-turn samples::

        from ragas import experiment
        from ragas.integrations.ag_ui import run_ag_ui_row, build_sample
        from ragas.metrics.collections import ToolCallF1

        @experiment()
        async def tool_experiment(row):
            enriched = await run_ag_ui_row(row, "http://localhost:8000/chat")

            # Build sample for tool metrics
            sample = build_sample(
                user_input=row["user_input"],
                messages=enriched["messages"],
                reference_tool_calls=row.get("reference_tool_calls"),
            )

            score = await ToolCallF1().multi_turn_ascore(sample)
            return {**enriched, "tool_call_f1": score}

        results = await tool_experiment.arun(dataset, name="tool_eval")

    Convert streaming AG-UI events to Ragas messages::

        from ragas.integrations.ag_ui import convert_to_ragas_messages
        from ag_ui.core import Event

        # List of AG-UI events from agent run
        ag_ui_events: List[Event] = [...]

        # Convert to Ragas messages
        ragas_messages = convert_to_ragas_messages(ag_ui_events, metadata=True)
"""

from __future__ import annotations

import json
import logging
import typing as t
import uuid
from typing import Any, Dict, List, Optional, Union

from ragas.dataset_schema import (
    MultiTurnSample,
    SingleTurnSample,
)
from ragas.messages import AIMessage, HumanMessage, ToolCall, ToolMessage

logger = logging.getLogger(__name__)

__all__ = [
    # Event collection
    "AGUIEventCollector",
    # Message conversion
    "convert_to_ragas_messages",
    "convert_messages_snapshot",
    "convert_messages_to_ag_ui",
    # Endpoint calling
    "call_ag_ui_endpoint",
    # Primary API
    "run_ag_ui_row",
    # Extraction helpers
    "extract_response",
    "extract_tool_calls",
    "extract_contexts",
    # Sample building
    "build_sample",
]

MISSING_CONTEXT_PLACEHOLDER = "[no retrieved contexts provided by agent]"
MISSING_RESPONSE_PLACEHOLDER = "[no response generated by agent]"


# Lazy imports for ag_ui to avoid hard dependency
def _import_ag_ui_core():
    """Import AG-UI core types with helpful error message."""
    try:
        from ag_ui.core import (
            BaseEvent,
            Event,
            EventType,
            MessagesSnapshotEvent,
            TextMessageChunkEvent,
            TextMessageContentEvent,
            TextMessageEndEvent,
            TextMessageStartEvent,
            ToolCallArgsEvent,
            ToolCallChunkEvent,
            ToolCallEndEvent,
            ToolCallResultEvent,
            ToolCallStartEvent,
        )

        return (
            BaseEvent,
            Event,
            EventType,
            MessagesSnapshotEvent,
            TextMessageStartEvent,
            TextMessageContentEvent,
            TextMessageEndEvent,
            TextMessageChunkEvent,
            ToolCallStartEvent,
            ToolCallArgsEvent,
            ToolCallEndEvent,
            ToolCallResultEvent,
            ToolCallChunkEvent,
        )
    except ImportError as e:
        raise ImportError(
            "AG-UI integration requires the ag-ui-protocol package. "
            "Install it with: pip install ag-ui-protocol"
        ) from e


class AGUIEventCollector:
    """
    Collects and reconstructs complete messages from streaming AG-UI events.

    AG-UI uses an event-based streaming protocol where messages are delivered
    incrementally through Start->Content->End event sequences (triads). This
    collector accumulates these events and reconstructs complete Ragas messages.
    It also supports convenience chunk events (TextMessageChunk, ToolCallChunk)
    for complete messages delivered in a single event.

    Attributes
    ----------
    messages : List[Union[HumanMessage, AIMessage, ToolMessage]]
        Accumulated complete messages ready for Ragas evaluation.
    include_metadata : bool
        Whether to include AG-UI metadata in converted messages.

    Example
    -------
    >>> collector = AGUIEventCollector(metadata=True)
    >>> for event in ag_ui_event_stream:
    ...     collector.process_event(event)
    >>> ragas_messages = collector.get_messages()
    """

    def __init__(self, metadata: bool = False):
        """
        Initialize the event collector.

        Parameters
        ----------
        metadata : bool, optional
            Whether to include AG-UI event metadata in Ragas messages (default: False)
        """
        self.include_metadata = metadata
        self.messages: List[Union[HumanMessage, AIMessage, ToolMessage]] = []

        # State tracking for streaming message reconstruction
        self._active_text_messages: Dict[str, Dict[str, Any]] = {}
        self._active_tool_calls: Dict[str, Dict[str, Any]] = {}
        self._completed_tool_calls: Dict[str, ToolCall] = {}

        # Context tracking for metadata
        self._current_run_id: Optional[str] = None
        self._current_thread_id: Optional[str] = None
        self._current_step: Optional[str] = None

        # Cache AG-UI imports to avoid repeated import calls
        (
            self._BaseEvent,
            self._Event,
            self._EventType,
            self._MessagesSnapshotEvent,
            self._TextMessageStartEvent,
            self._TextMessageContentEvent,
            self._TextMessageEndEvent,
            self._TextMessageChunkEvent,
            self._ToolCallStartEvent,
            self._ToolCallArgsEvent,
            self._ToolCallEndEvent,
            self._ToolCallResultEvent,
            self._ToolCallChunkEvent,
        ) = _import_ag_ui_core()

    def _get_pending_tool_calls(self) -> Optional[List[ToolCall]]:
        """
        Retrieve and clear any completed tool calls waiting to be attached to a message.

        Returns
        -------
        Optional[List[ToolCall]]
            List of pending tool calls if any exist, None otherwise.
        """
        if self._completed_tool_calls:
            tool_calls = list(self._completed_tool_calls.values())
            self._completed_tool_calls.clear()
            return tool_calls
        return None

    def process_event(self, event: Any) -> None:
        """
        Process a single AG-UI event and update internal state.

        Parameters
        ----------
        event : Event
            An AG-UI protocol event from ag_ui.core

        Notes
        -----
        This method handles different event types:
        - Lifecycle events (RUN_STARTED, STEP_STARTED): Update context
        - Text message events: Accumulate and reconstruct messages (streaming triads or chunks)
        - Tool call events: Reconstruct tool calls and results (streaming triads or chunks)
        - Other events: Silently ignored
        """
        # Use cached AG-UI imports
        EventType = self._EventType

        event_type = event.type

        # Update context from lifecycle events
        if event_type == EventType.RUN_STARTED:
            self._current_run_id = event.run_id
            self._current_thread_id = event.thread_id
        elif event_type == EventType.STEP_STARTED:
            self._current_step = event.step_name
        elif event_type == EventType.STEP_FINISHED:
            if event.step_name == self._current_step:
                self._current_step = None

        # Handle text message events
        elif event_type == EventType.TEXT_MESSAGE_START:
            self._handle_text_message_start(event)
        elif event_type == EventType.TEXT_MESSAGE_CONTENT:
            self._handle_text_message_content(event)
        elif event_type == EventType.TEXT_MESSAGE_END:
            self._handle_text_message_end(event)
        elif event_type == EventType.TEXT_MESSAGE_CHUNK:
            self._handle_text_message_chunk(event)

        # Handle tool call events
        elif event_type == EventType.TOOL_CALL_START:
            self._handle_tool_call_start(event)
        elif event_type == EventType.TOOL_CALL_ARGS:
            self._handle_tool_call_args(event)
        elif event_type == EventType.TOOL_CALL_END:
            self._handle_tool_call_end(event)
        elif event_type == EventType.TOOL_CALL_RESULT:
            self._handle_tool_call_result(event)
        elif event_type == EventType.TOOL_CALL_CHUNK:
            self._handle_tool_call_chunk(event)

        # MessagesSnapshot provides complete history
        elif event_type == EventType.MESSAGES_SNAPSHOT:
            self._handle_messages_snapshot(event)

        # Ignore lifecycle, state management, and other events
        else:
            logger.debug(f"Ignoring AG-UI event type: {event_type}")

    def _handle_text_message_start(self, event: Any) -> None:
        """Initialize a new streaming text message."""
        self._active_text_messages[event.message_id] = {
            "message_id": event.message_id,
            "role": event.role,
            "content_chunks": [],
            "timestamp": event.timestamp,
        }

    def _handle_text_message_content(self, event: Any) -> None:
        """Accumulate text content chunk for a streaming message."""
        if event.message_id in self._active_text_messages:
            self._active_text_messages[event.message_id]["content_chunks"].append(
                event.delta
            )
        else:
            logger.warning(
                f"Received TextMessageContent for unknown message_id: {event.message_id}"
            )

    def _handle_text_message_end(self, event: Any) -> None:
        """Finalize a streaming text message and convert to Ragas format."""
        if event.message_id not in self._active_text_messages:
            logger.warning(
                f"Received TextMessageEnd for unknown message_id: {event.message_id}"
            )
            return

        msg_data = self._active_text_messages.pop(event.message_id)
        content = "".join(msg_data["content_chunks"])
        role = msg_data["role"]

        # Build metadata if requested
        metadata = None
        if self.include_metadata:
            metadata = {
                "message_id": msg_data["message_id"],
                "timestamp": msg_data["timestamp"],
            }
            if self._current_run_id:
                metadata["run_id"] = self._current_run_id
            if self._current_thread_id:
                metadata["thread_id"] = self._current_thread_id
            if self._current_step:
                metadata["step_name"] = self._current_step

        # Convert to appropriate Ragas message type
        if role == "assistant":
            # Check if there are completed tool calls for this message
            # Tool calls are associated by being emitted before the message end
            tool_calls = self._get_pending_tool_calls()

            self.messages.append(
                AIMessage(content=content, tool_calls=tool_calls, metadata=metadata)
            )
        elif role == "user":
            self.messages.append(HumanMessage(content=content, metadata=metadata))
        else:
            logger.warning(f"Unexpected message role: {role}")

    def _handle_tool_call_start(self, event: Any) -> None:
        """Initialize a new streaming tool call."""
        self._active_tool_calls[event.tool_call_id] = {
            "tool_call_id": event.tool_call_id,
            "tool_call_name": event.tool_call_name,
            "parent_message_id": getattr(event, "parent_message_id", None),
            "args_chunks": [],
            "timestamp": event.timestamp,
        }

    def _handle_tool_call_args(self, event: Any) -> None:
        """Accumulate tool argument chunks."""
        if event.tool_call_id in self._active_tool_calls:
            self._active_tool_calls[event.tool_call_id]["args_chunks"].append(
                event.delta
            )
        else:
            logger.warning(
                f"Received ToolCallArgs for unknown tool_call_id: {event.tool_call_id}"
            )

    def _handle_tool_call_end(self, event: Any) -> None:
        """Finalize a tool call specification (args are complete, but not yet executed)."""
        if event.tool_call_id not in self._active_tool_calls:
            logger.warning(
                f"Received ToolCallEnd for unknown tool_call_id: {event.tool_call_id}"
            )
            return

        tool_data = self._active_tool_calls.pop(event.tool_call_id)
        args_json = "".join(tool_data["args_chunks"])

        # Parse tool arguments
        try:
            args = json.loads(args_json) if args_json else {}
        except json.JSONDecodeError:
            logger.error(
                f"Failed to parse tool call arguments for {tool_data['tool_call_name']}: {args_json}"
            )
            args = {"raw_args": args_json}

        # Store completed tool call for association with next AI message
        self._completed_tool_calls[event.tool_call_id] = ToolCall(
            name=tool_data["tool_call_name"], args=args
        )

    def _handle_tool_call_result(self, event: Any) -> None:
        """
        Convert tool call result to Ragas ToolMessage.

        Also ensures that the most recent AIMessage has tool_calls attached,
        which is required for MultiTurnSample validation (ToolMessage must be
        preceded by an AIMessage with tool_calls).
        """
        # Find the most recent AIMessage
        ai_msg_idx = None
        for i in range(len(self.messages) - 1, -1, -1):
            if isinstance(self.messages[i], AIMessage):
                ai_msg_idx = i
                break

        # Ensure the AIMessage has tool_calls
        if ai_msg_idx is not None:
            ai_msg_candidate = self.messages[ai_msg_idx]

            if not isinstance(ai_msg_candidate, AIMessage):
                logger.warning(
                    "Expected AIMessage when handling tool call result, "
                    f"received {type(ai_msg_candidate).__name__}"
                )
                return

            ai_msg = ai_msg_candidate

            # If it doesn't have tool_calls, we need to add them
            if ai_msg.tool_calls is None or len(ai_msg.tool_calls) == 0:
                # Check if there are unclaimed tool calls
                if self._completed_tool_calls:
                    # Attach unclaimed tool calls
                    new_tool_calls = list(self._completed_tool_calls.values())
                    self.messages[ai_msg_idx] = AIMessage(
                        content=ai_msg.content,
                        metadata=ai_msg.metadata,
                        tool_calls=new_tool_calls,
                    )
                    self._completed_tool_calls.clear()
                else:
                    # No unclaimed tool calls, create a synthetic one
                    # This can happen if tool calls were already attached but lost somehow
                    logger.warning(
                        f"ToolCallResult for {event.tool_call_id} but preceding AIMessage "
                        f"has no tool_calls. Creating synthetic tool call."
                    )
                    synthetic_tool_call = ToolCall(
                        name="unknown_tool",  # We don't have the tool name
                        args={},
                    )
                    self.messages[ai_msg_idx] = AIMessage(
                        content=ai_msg.content,
                        metadata=ai_msg.metadata,
                        tool_calls=[synthetic_tool_call],
                    )
            elif self._completed_tool_calls:
                # AIMessage already has tool_calls, but there are unclaimed ones
                # Append them
                existing_tool_calls = ai_msg.tool_calls or []
                new_tool_calls = list(self._completed_tool_calls.values())
                self.messages[ai_msg_idx] = AIMessage(
                    content=ai_msg.content,
                    metadata=ai_msg.metadata,
                    tool_calls=existing_tool_calls + new_tool_calls,
                )
                self._completed_tool_calls.clear()
        else:
            # No AIMessage found at all - create one
            logger.warning(
                "ToolCallResult received but no AIMessage found. Creating synthetic AIMessage."
            )
            if self._completed_tool_calls:
                new_tool_calls = list(self._completed_tool_calls.values())
            else:
                new_tool_calls = [ToolCall(name="unknown_tool", args={})]

            self.messages.append(
                AIMessage(content="", metadata=None, tool_calls=new_tool_calls)
            )
            self._completed_tool_calls.clear()

        metadata = None
        if self.include_metadata:
            metadata = {
                "tool_call_id": event.tool_call_id,
                "message_id": event.message_id,
                "timestamp": event.timestamp,
            }
            if self._current_run_id:
                metadata["run_id"] = self._current_run_id
            if self._current_thread_id:
                metadata["thread_id"] = self._current_thread_id

        self.messages.append(ToolMessage(content=event.content, metadata=metadata))

    def _handle_text_message_chunk(self, event: Any) -> None:
        """
        Process a TextMessageChunkEvent - a convenience event combining start, content, and end.

        This handler processes complete messages available at once, bypassing the
        Start-Content-End streaming sequence.
        """
        # Extract message data from chunk event
        message_id = getattr(event, "message_id", None)
        role = getattr(event, "role", "assistant")
        content = getattr(event, "delta", "")

        # Build metadata if requested
        metadata = None
        if self.include_metadata:
            metadata = {
                "timestamp": event.timestamp,
            }
            if message_id:
                metadata["message_id"] = message_id
            if self._current_run_id:
                metadata["run_id"] = self._current_run_id
            if self._current_thread_id:
                metadata["thread_id"] = self._current_thread_id
            if self._current_step:
                metadata["step_name"] = self._current_step

        # Convert to appropriate Ragas message type
        if role == "assistant":
            # Check if there are completed tool calls for this message
            tool_calls = self._get_pending_tool_calls()

            self.messages.append(
                AIMessage(content=content, tool_calls=tool_calls, metadata=metadata)
            )
        elif role == "user":
            self.messages.append(HumanMessage(content=content, metadata=metadata))
        else:
            logger.warning(f"Unexpected message role in chunk event: {role}")

    def _handle_tool_call_chunk(self, event: Any) -> None:
        """
        Process a ToolCallChunkEvent - a convenience event combining tool call specification.

        This handler processes complete tool calls available at once, bypassing the
        Start-Args-End streaming sequence.
        """
        # Extract tool call data from chunk event
        tool_call_id = getattr(event, "tool_call_id", None)
        tool_call_name = getattr(event, "tool_call_name", None)
        args_delta = getattr(event, "delta", None)

        if not tool_call_name:
            logger.warning("Received ToolCallChunk without tool_call_name")
            return

        # Parse tool arguments from delta if provided
        args = {}
        if args_delta:
            if isinstance(args_delta, str):
                try:
                    args = json.loads(args_delta)
                except json.JSONDecodeError:
                    logger.error(
                        f"Failed to parse tool call arguments for {tool_call_name}: {args_delta}"
                    )
                    args = {"raw_args": args_delta}
            elif isinstance(args_delta, dict):
                args = args_delta
            else:
                args = {"raw_args": str(args_delta)}

        # Store completed tool call for association with next AI message
        if tool_call_id:
            self._completed_tool_calls[tool_call_id] = ToolCall(
                name=tool_call_name, args=args
            )
        else:
            # If no ID provided, generate one
            temp_id = f"chunk_{len(self._completed_tool_calls)}"
            self._completed_tool_calls[temp_id] = ToolCall(
                name=tool_call_name, args=args
            )

    def _handle_messages_snapshot(self, event: Any) -> None:
        """
        Process a MessagesSnapshotEvent containing complete message history.

        This bypasses streaming reconstruction and directly converts
        AG-UI Message objects to Ragas format using type-based checking.
        """
        # Import AG-UI message types for type checking
        try:
            from ag_ui.core import (
                AssistantMessage,
                ToolMessage as AGUIToolMessage,
                UserMessage,
            )
        except ImportError as e:
            raise ImportError(
                "AG-UI message types are required for snapshot processing. "
                "Install with: pip install ag-ui-protocol"
            ) from e

        for msg in event.messages:
            content = str(getattr(msg, "content", ""))

            metadata = None
            if self.include_metadata:
                metadata = {"source": "messages_snapshot"}
                if hasattr(msg, "id"):
                    metadata["message_id"] = msg.id

            # Type-based checking for AG-UI Message objects
            if isinstance(msg, AssistantMessage):
                # Check for tool calls in message
                tool_calls = None
                if hasattr(msg, "tool_calls") and msg.tool_calls:
                    tool_calls = []
                    for tc in msg.tool_calls:
                        tc_obj = t.cast(Any, tc)
                        name = t.cast(str, getattr(tc_obj, "name", "unknown_tool"))
                        raw_args = getattr(tc_obj, "args", {})
                        if not isinstance(raw_args, dict):
                            raw_args = {"raw_args": raw_args}
                        tool_calls.append(
                            ToolCall(
                                name=name,
                                args=t.cast(Dict[str, Any], raw_args),
                            )
                        )
                self.messages.append(
                    AIMessage(content=content, tool_calls=tool_calls, metadata=metadata)
                )
            elif isinstance(msg, UserMessage):
                self.messages.append(HumanMessage(content=content, metadata=metadata))
            elif isinstance(msg, AGUIToolMessage):
                self.messages.append(ToolMessage(content=content, metadata=metadata))
            else:
                logger.debug(
                    f"Skipping message with unknown type: {type(msg).__name__}"
                )

    def get_messages(self) -> List[Union[HumanMessage, AIMessage, ToolMessage]]:
        """
        Retrieve all accumulated Ragas messages.

        Returns
        -------
        List[Union[HumanMessage, AIMessage, ToolMessage]]
            Complete list of Ragas messages reconstructed from AG-UI events.

        Notes
        -----
        This returns a copy of the accumulated messages. The collector's
        internal state is not cleared, so calling this multiple times
        returns the same messages.
        """
        return self.messages.copy()

    def clear(self) -> None:
        """
        Clear all accumulated messages and reset internal state.

        Useful for reusing the same collector instance for multiple
        conversation sessions.
        """
        self.messages.clear()
        self._active_text_messages.clear()
        self._active_tool_calls.clear()
        self._completed_tool_calls.clear()
        self._current_run_id = None
        self._current_thread_id = None
        self._current_step = None


def convert_to_ragas_messages(
    events: List[Any],
    metadata: bool = False,
) -> List[Union[HumanMessage, AIMessage, ToolMessage]]:
    """
    Convert a sequence of AG-UI protocol events to Ragas message format.

    This function processes AG-UI events and reconstructs complete messages
    from streaming event sequences (Start->Content->End patterns). It handles
    text messages, tool calls, and filters out non-message events like
    lifecycle and state management events.

    Parameters
    ----------
    events : List[Event]
        List of AG-UI protocol events from ag_ui.core. Can contain any mix
        of event types - non-message events are automatically filtered out.
    metadata : bool, optional
        Whether to include AG-UI event metadata (run_id, thread_id, timestamps)
        in the converted Ragas messages (default: False).

    Returns
    -------
    List[Union[HumanMessage, AIMessage, ToolMessage]]
        List of Ragas messages ready for evaluation. Messages preserve
        conversation order and tool call associations.

    Raises
    ------
    ImportError
        If the ag-ui-protocol package is not installed.

    Examples
    --------
    Convert AG-UI events from an agent run::

        >>> from ragas.integrations.ag_ui import convert_to_ragas_messages
        >>> from ag_ui.core import (
        ...     RunStartedEvent, TextMessageStartEvent,
        ...     TextMessageContentEvent, TextMessageEndEvent
        ... )
        >>>
        >>> events = [
        ...     RunStartedEvent(run_id="run-1", thread_id="thread-1"),
        ...     TextMessageStartEvent(message_id="msg-1", role="assistant"),
        ...     TextMessageContentEvent(message_id="msg-1", delta="Hello"),
        ...     TextMessageContentEvent(message_id="msg-1", delta=" world"),
        ...     TextMessageEndEvent(message_id="msg-1"),
        ... ]
        >>> messages = convert_to_ragas_messages(events, metadata=True)
        >>> messages[0].content
        'Hello world'

    Process events with tool calls::

        >>> events = [
        ...     TextMessageStartEvent(message_id="msg-1", role="assistant"),
        ...     TextMessageContentEvent(message_id="msg-1", delta="Let me check"),
        ...     TextMessageEndEvent(message_id="msg-1"),
        ...     ToolCallStartEvent(
        ...         tool_call_id="tc-1",
        ...         tool_call_name="get_weather",
        ...         parent_message_id="msg-1"
        ...     ),
        ...     ToolCallArgsEvent(tool_call_id="tc-1", delta='{"city": "SF"}'),
        ...     ToolCallEndEvent(tool_call_id="tc-1"),
        ...     ToolCallResultEvent(
        ...         tool_call_id="tc-1",
        ...         message_id="result-1",
        ...         content="Sunny, 72°F"
        ...     ),
        ... ]
        >>> messages = convert_to_ragas_messages(events)
        >>> len(messages)
        2  # AI message + Tool result message

    Notes
    -----
    - Streaming events (Start->Content->End) are automatically reconstructed
    - Tool calls are associated with the preceding AI message
    - Non-message events (lifecycle, state) are silently filtered
    - Incomplete event sequences are logged as warnings
    - AG-UI metadata can be preserved in message.metadata when metadata=True

    See Also
    --------
    convert_messages_snapshot : Convert complete message history from snapshot
    AGUIEventCollector : Lower-level API for streaming event collection
    """
    collector = AGUIEventCollector(metadata=metadata)

    for event in events:
        collector.process_event(event)

    return collector.get_messages()


def convert_messages_snapshot(
    snapshot_event: Any,
    metadata: bool = False,
) -> List[Union[HumanMessage, AIMessage, ToolMessage]]:
    """
    Convert an AG-UI MessagesSnapshotEvent to Ragas message format.

    MessagesSnapshotEvent provides a complete conversation history in a
    single event, bypassing the need to reconstruct from streaming events.
    This is more efficient when the complete history is already available.

    Parameters
    ----------
    snapshot_event : MessagesSnapshotEvent
        AG-UI event containing complete message history array.
    metadata : bool, optional
        Whether to include metadata in converted messages (default: False).

    Returns
    -------
    List[Union[HumanMessage, AIMessage, ToolMessage]]
        List of Ragas messages from the snapshot.

    Raises
    ------
    ImportError
        If the ag-ui-protocol package is not installed.

    Examples
    --------
    >>> from ragas.integrations.ag_ui import convert_messages_snapshot
    >>> from ag_ui.core import MessagesSnapshotEvent
    >>>
    >>> snapshot = MessagesSnapshotEvent(messages=[
    ...     {"role": "user", "content": "What's the weather?"},
    ...     {"role": "assistant", "content": "Let me check for you."},
    ... ])
    >>> messages = convert_messages_snapshot(snapshot)
    >>> len(messages)
    2

    Notes
    -----
    This is the preferred method when working with complete conversation
    history. It's faster than processing streaming events and avoids the
    complexity of event sequence reconstruction.

    See Also
    --------
    convert_to_ragas_messages : Convert streaming event sequences
    """
    collector = AGUIEventCollector(metadata=metadata)

    # Type check using cached import from collector
    if not isinstance(snapshot_event, collector._MessagesSnapshotEvent):
        raise TypeError(
            f"Expected MessagesSnapshotEvent, got {type(snapshot_event).__name__}"
        )
    collector._handle_messages_snapshot(snapshot_event)
    return collector.get_messages()


def convert_messages_to_ag_ui(
    messages: List[Union[HumanMessage, AIMessage, ToolMessage]],
) -> List[Any]:
    """
    Convert Ragas messages to AG-UI message format.

    This function transforms a list of Ragas message objects into AG-UI protocol
    message format for sending to AG-UI endpoints. It handles conversion of:
    - HumanMessage → UserMessage
    - AIMessage → AssistantMessage (with tool_calls if present)
    - ToolMessage → ToolMessage (AG-UI format)

    Parameters
    ----------
    messages : List[Union[HumanMessage, AIMessage, ToolMessage]]
        List of Ragas messages from MultiTurnSample.user_input

    Returns
    -------
    List[Any]
        List of AG-UI protocol messages (UserMessage, AssistantMessage, ToolMessage)

    Examples
    --------
    >>> from ragas.messages import HumanMessage, AIMessage, ToolCall
    >>> messages = [
    ...     HumanMessage(content="What's the weather?"),
    ...     AIMessage(content="Let me check", tool_calls=[
    ...         ToolCall(name="get-weather", args={"location": "SF"})
    ...     ])
    ... ]
    >>> ag_ui_messages = convert_messages_to_ag_ui(messages)
    """
    try:
        from ag_ui.core import (
            AssistantMessage,
            FunctionCall,
            ToolCall as AGUIToolCall,
            UserMessage,
        )
    except ImportError as e:
        raise ImportError(
            "ag-ui-protocol package is required for AG-UI integration. "
            "Install it with: pip install ag-ui-protocol"
        ) from e

    ag_ui_messages = []

    for idx, msg in enumerate(messages):
        msg_id = str(idx + 1)

        if isinstance(msg, HumanMessage):
            ag_ui_messages.append(UserMessage(id=msg_id, content=msg.content))

        elif isinstance(msg, AIMessage):
            # Convert Ragas ToolCall to AG-UI ToolCall format
            tool_calls = None
            if msg.tool_calls:
                tool_calls = [
                    AGUIToolCall(
                        id=f"tc-{idx}-{tc_idx}",
                        function=FunctionCall(
                            name=tc.name,
                            arguments=json.dumps(tc.args)
                            if isinstance(tc.args, dict)
                            else tc.args,
                        ),
                    )
                    for tc_idx, tc in enumerate(msg.tool_calls)
                ]

            ag_ui_messages.append(
                AssistantMessage(
                    id=msg_id, content=msg.content or "", tool_calls=tool_calls
                )
            )

        elif isinstance(msg, ToolMessage):
            # Note: AG-UI ToolMessage requires toolCallId which Ragas ToolMessage doesn't have.
            # ToolMessage is typically sent FROM agent, not TO agent in initial conversation.
            # For now, we skip ToolMessage in the conversion.
            logger.warning(
                "Skipping ToolMessage in AG-UI conversion - ToolMessage is typically "
                "sent from agent, not to agent"
            )
            continue

    return ag_ui_messages


async def call_ag_ui_endpoint(
    endpoint_url: str,
    user_input: Union[str, List[Union[HumanMessage, AIMessage, ToolMessage]]],
    thread_id: Optional[str] = None,
    agent_config: Optional[Dict[str, Any]] = None,
    timeout: float = 60.0,
    extra_headers: Optional[Dict[str, str]] = None,
) -> List[Any]:
    """
    Call an AG-UI FastAPI endpoint and collect streaming events.

    Makes an HTTP POST request to an AG-UI compatible FastAPI endpoint
    and parses the Server-Sent Events (SSE) stream to collect all events.

    Parameters
    ----------
    endpoint_url : str
        The URL of the AG-UI FastAPI endpoint (e.g., "http://localhost:8000/agent").
    user_input : Union[str, List[Union[HumanMessage, AIMessage, ToolMessage]]]
        The user message/query to send to the agent. Can be either:
        - A string for single-turn queries
        - A list of Ragas messages for multi-turn conversations
    thread_id : str, optional
        Optional thread ID for conversation continuity.
    agent_config : dict, optional
        Optional agent configuration parameters.
    timeout : float, optional
        Request timeout in seconds (default: 60.0).
    extra_headers : dict, optional
        Optional extra HTTP headers to include in the request (default: None).
        These will be merged with the default "Accept: text/event-stream" header.

    Returns
    -------
    List[Event]
        List of AG-UI events collected from the SSE stream.

    Raises
    ------
    ImportError
        If httpx is not installed.
    httpx.HTTPError
        If the HTTP request fails.

    Notes
    -----
    This function expects the endpoint to return Server-Sent Events (SSE)
    with content type "text/event-stream". Each event should be in the format:

        data: {"type": "...", ...}\\n\\n

    The function will parse the SSE stream and deserialize each event
    using AG-UI's RunAgentInput model.
    """
    try:
        import httpx
    except ImportError as e:
        raise ImportError(
            "AG-UI FastAPI integration requires httpx. "
            "Install it with: pip install httpx"
        ) from e

    # Import AG-UI types
    try:
        from ag_ui.core import Event, RunAgentInput, UserMessage
        from pydantic import TypeAdapter
    except ImportError as e:
        raise ImportError(
            "AG-UI integration requires the ag-ui-protocol package. "
            "Install it with: pip install ag-ui-protocol"
        ) from e

    # Create TypeAdapter for Event discriminated union
    # This properly handles the union of all event types based on the 'type' discriminator
    event_adapter = TypeAdapter(Event)

    # Convert user_input to AG-UI messages
    ag_ui_messages: List[Any]
    if isinstance(user_input, str):
        # Single-turn: simple string input
        ag_ui_messages = t.cast(List[Any], [UserMessage(id="1", content=user_input)])
    else:
        # Multi-turn: list of Ragas messages
        ag_ui_messages = convert_messages_to_ag_ui(user_input)

    # Prepare request payload
    payload = RunAgentInput(
        thread_id=thread_id
        or f"thread_{uuid.uuid4()}",  # Generate thread ID if not provided
        run_id=f"run_{uuid.uuid4()}",  # Generate a unique run ID
        messages=t.cast(Any, ag_ui_messages),
        state={},
        tools=[],
        context=[],
        forwarded_props={},
    )

    # Collect events from SSE stream
    events: List[Any] = []

    # Merge default headers with extra headers
    headers = {"Accept": "text/event-stream"}
    if extra_headers:
        headers.update(extra_headers)

    async with httpx.AsyncClient(timeout=timeout, follow_redirects=True) as client:
        async with client.stream(
            "POST",
            endpoint_url,
            json=payload.model_dump(exclude_none=True),
            headers=headers,
        ) as response:
            response.raise_for_status()

            # Parse SSE stream line by line
            async for line in response.aiter_lines():
                line = line.strip()

                # SSE format: "data: {...}"
                if line.startswith("data: "):
                    json_data = line[6:]  # Remove "data: " prefix

                    try:
                        # Parse JSON and convert to Event using TypeAdapter
                        # TypeAdapter properly handles discriminated unions based on 'type' field
                        event_dict = json.loads(json_data)
                        event = event_adapter.validate_python(event_dict)
                        events.append(event)
                    except (json.JSONDecodeError, ValueError) as e:
                        logger.warning(f"Failed to parse SSE event: {e}")
                        continue

    return events


# ---------------------------------------------------------------------------
# Extraction Helpers
# ---------------------------------------------------------------------------


def extract_response(
    messages: List[Union[HumanMessage, AIMessage, ToolMessage]],
) -> str:
    """
    Extract concatenated AI response text from messages.

    Parameters
    ----------
    messages : List[Message]
        List of Ragas messages (typically from convert_to_ragas_messages).

    Returns
    -------
    str
        Concatenated content from all AIMessage instances.
        Returns empty string if no AI content found.

    Example
    -------
    >>> messages = convert_to_ragas_messages(events)
    >>> response = extract_response(messages)
    """
    return "".join(
        m.content for m in messages if isinstance(m, AIMessage) and m.content
    )


def extract_tool_calls(
    messages: List[Union[HumanMessage, AIMessage, ToolMessage]],
) -> List[ToolCall]:
    """
    Extract all tool calls from AI messages.

    Parameters
    ----------
    messages : List[Message]
        List of Ragas messages (typically from convert_to_ragas_messages).

    Returns
    -------
    List[ToolCall]
        List of ToolCall objects from all AIMessage instances.

    Example
    -------
    >>> messages = convert_to_ragas_messages(events)
    >>> tool_calls = extract_tool_calls(messages)
    """
    tool_calls: List[ToolCall] = []
    for m in messages:
        if isinstance(m, AIMessage) and m.tool_calls:
            tool_calls.extend(m.tool_calls)
    return tool_calls


def extract_contexts(
    messages: List[Union[HumanMessage, AIMessage, ToolMessage]],
) -> List[str]:
    """
    Extract tool results/contexts from messages.

    Parameters
    ----------
    messages : List[Message]
        List of Ragas messages (typically from convert_to_ragas_messages).

    Returns
    -------
    List[str]
        List of content strings from all ToolMessage instances.

    Example
    -------
    >>> messages = convert_to_ragas_messages(events)
    >>> contexts = extract_contexts(messages)
    """
    return [m.content for m in messages if isinstance(m, ToolMessage) and m.content]


# ---------------------------------------------------------------------------
# Sample Building Helper
# ---------------------------------------------------------------------------


def build_sample(
    user_input: Union[str, List[Union[HumanMessage, AIMessage, ToolMessage]]],
    messages: List[Union[HumanMessage, AIMessage, ToolMessage]],
    reference: Optional[str] = None,
    reference_tool_calls: Optional[Union[str, List[ToolCall]]] = None,
) -> Union[SingleTurnSample, MultiTurnSample]:
    """
    Build appropriate sample type based on inputs.

    Returns MultiTurnSample if:
    - user_input is a conversation list, OR
    - reference_tool_calls are provided

    Otherwise returns SingleTurnSample.

    Parameters
    ----------
    user_input : str or List[Message]
        The original user input - either a string or conversation list.
    messages : List[Message]
        Agent response messages from convert_to_ragas_messages().
    reference : str, optional
        Reference/expected answer for evaluation.
    reference_tool_calls : str or List[ToolCall], optional
        Expected tool calls for tool evaluation metrics. Can be a JSON string
        (e.g., from CSV) or a list of ToolCall dicts.

    Returns
    -------
    SingleTurnSample or MultiTurnSample
        Appropriate sample type for metric scoring.

    Example
    -------
    >>> enriched = await run_ag_ui_row(row, endpoint_url)
    >>> sample = build_sample(
    ...     user_input=row["user_input"],
    ...     messages=enriched["messages"],
    ...     reference=row.get("reference"),
    ...     reference_tool_calls=row.get("reference_tool_calls"),
    ... )
    >>> score = await my_metric.ascore(sample)
    """
    # Parse reference_tool_calls if it's a JSON string (e.g., from CSV)
    parsed_tool_calls: Optional[List[ToolCall]] = None
    if reference_tool_calls is not None:
        if isinstance(reference_tool_calls, str):
            try:
                parsed_tool_calls = json.loads(reference_tool_calls)
            except json.JSONDecodeError:
                logger.warning(
                    f"Failed to parse reference_tool_calls as JSON: {reference_tool_calls}"
                )
                parsed_tool_calls = None
        else:
            parsed_tool_calls = reference_tool_calls

    needs_multi_turn = isinstance(user_input, list) or parsed_tool_calls is not None

    if needs_multi_turn:
        # Build conversation with user input + agent responses
        conversation: List[Union[HumanMessage, AIMessage, ToolMessage]]
        if isinstance(user_input, list):
            conversation = [
                msg
                if isinstance(msg, (HumanMessage, AIMessage, ToolMessage))
                else HumanMessage(content=str(msg))
                for msg in user_input
            ]
        else:
            conversation = [HumanMessage(content=str(user_input))]

        # Add agent responses to conversation
        for msg in messages:
            if isinstance(msg, (AIMessage, ToolMessage)):
                conversation.append(msg)

        return MultiTurnSample(
            user_input=conversation,
            reference=reference,
            reference_tool_calls=parsed_tool_calls,
        )
    else:
        # Single-turn sample
        response_text = extract_response(messages)
        context_list = extract_contexts(messages)

        return SingleTurnSample(
            user_input=str(user_input),
            response=response_text or MISSING_RESPONSE_PLACEHOLDER,
            reference=reference,
            retrieved_contexts=context_list
            if context_list
            else [MISSING_CONTEXT_PLACEHOLDER],
        )


# ---------------------------------------------------------------------------
# Primary API: run_ag_ui_row
# ---------------------------------------------------------------------------


async def run_ag_ui_row(
    row: Dict[str, Any],
    endpoint_url: str,
    timeout: float = 60.0,
    metadata: bool = False,
    extra_headers: Optional[Dict[str, str]] = None,
) -> Dict[str, Any]:
    """
    Run a single row against an AG-UI endpoint and return enriched data.

    This function:
    1. Calls the AG-UI endpoint with row["user_input"]
    2. Converts SSE events to Ragas messages
    3. Extracts response, tool calls, and contexts
    4. Returns the row enriched with agent output

    Use this function inside an @experiment-decorated function to evaluate
    AG-UI agents. The framework handles dataset iteration and result collection.

    Parameters
    ----------
    row : Dict[str, Any]
        Input row containing at minimum "user_input" field.
    endpoint_url : str
        URL of the AG-UI endpoint (e.g., "http://localhost:8000/chat").
    timeout : float, optional
        Request timeout in seconds (default: 60.0).
    metadata : bool, optional
        Whether to include AG-UI metadata in messages (default: False).
    extra_headers : Dict[str, str], optional
        Additional HTTP headers for the request.

    Returns
    -------
    Dict[str, Any]
        Original row enriched with:
        - "response": str - Concatenated AI response text
        - "messages": List[Message] - Full message list
        - "tool_calls": List[ToolCall] - Extracted tool calls
        - "contexts": List[str] - Tool results/contexts

    Example
    -------
    Basic usage with @experiment::

        from ragas import experiment
        from ragas.integrations.ag_ui import run_ag_ui_row

        @experiment()
        async def my_experiment(row):
            enriched = await run_ag_ui_row(row, "http://localhost:8000/chat")
            score = await my_metric.ascore(
                response=enriched["response"],
                reference=row["reference"],
            )
            return {**enriched, "my_score": score.value}

        results = await my_experiment.arun(dataset, name="my_eval")

    With tool evaluation::

        from ragas.integrations.ag_ui import run_ag_ui_row, build_sample
        from ragas.metrics.collections import ToolCallF1

        @experiment()
        async def tool_experiment(row):
            enriched = await run_ag_ui_row(row, "http://localhost:8000/chat")
            sample = build_sample(
                user_input=row["user_input"],
                messages=enriched["messages"],
                reference_tool_calls=row.get("reference_tool_calls"),
            )
            score = await ToolCallF1().multi_turn_ascore(sample)
            return {**enriched, "tool_call_f1": score}

    See Also
    --------
    call_ag_ui_endpoint : Lower-level endpoint caller (returns raw events)
    convert_to_ragas_messages : Convert events to messages
    build_sample : Build SingleTurnSample or MultiTurnSample for metrics
    """
    user_input = row.get("user_input")

    if user_input is None:
        logger.error("Row missing required 'user_input' field")
        return {
            **row,
            "response": MISSING_RESPONSE_PLACEHOLDER,
            "messages": [],
            "tool_calls": [],
            "contexts": [MISSING_CONTEXT_PLACEHOLDER],
        }

    try:
        # Call AG-UI endpoint
        events = await call_ag_ui_endpoint(
            endpoint_url=endpoint_url,
            user_input=user_input,
            thread_id=f"thread-{uuid.uuid4()}",
            timeout=timeout,
            extra_headers=extra_headers,
        )

        # Convert events to Ragas messages
        messages = convert_to_ragas_messages(events, metadata=metadata)

        # Extract response, tool calls, and contexts
        return {
            **row,
            "response": extract_response(messages) or MISSING_RESPONSE_PLACEHOLDER,
            "messages": messages,
            "tool_calls": extract_tool_calls(messages),
            "contexts": extract_contexts(messages) or [MISSING_CONTEXT_PLACEHOLDER],
        }

    except Exception as e:
        logger.error(f"AG-UI endpoint call failed: {e}")
        return {
            **row,
            "response": MISSING_RESPONSE_PLACEHOLDER,
            "messages": [],
            "tool_calls": [],
            "contexts": [MISSING_CONTEXT_PLACEHOLDER],
        }
